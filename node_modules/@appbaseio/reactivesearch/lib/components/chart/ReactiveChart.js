'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _echartsForReact = require('echarts-for-react');

var _echartsForReact2 = _interopRequireDefault(_echartsForReact);

var _types = require('@appbaseio/reactivecore/lib/utils/types');

var _types2 = _interopRequireDefault(_types);

var _propTypes = require('prop-types');

var _hoistNonReactStatics = require('hoist-non-react-statics');

var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

var _actions = require('@appbaseio/reactivecore/lib/actions');

var _transform = require('@appbaseio/reactivecore/lib/utils/transform');

var _constants = require('@appbaseio/reactivecore/lib/utils/constants');

var _helper = require('@appbaseio/reactivecore/lib/utils/helper');

var _utils = require('../../utils');

var _PreferencesConsumer = require('../basic/PreferencesConsumer');

var _PreferencesConsumer2 = _interopRequireDefault(_PreferencesConsumer);

var _ComponentWrapper = require('../basic/ComponentWrapper');

var _ComponentWrapper2 = _interopRequireDefault(_ComponentWrapper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ChartTypes = {
	Pie: 'pie',
	Scatter: 'scatter',
	Histogram: 'histogram',
	Line: 'line',
	Bar: 'bar'
};

var ReactiveChart = function (_React$Component) {
	_inherits(ReactiveChart, _React$Component);

	function ReactiveChart(props) {
		_classCallCheck(this, ReactiveChart);

		var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

		_initialiseProps.call(_this);

		var defaultValue = props.value;
		var currentValue = props.selectedValue || defaultValue;
		var options = _this.transformOptions(props.options, props);

		_this.state = {
			currentValue: currentValue,
			options: options
		};
		_this.internalComponent = (0, _transform.getInternalComponentID)(props.componentId);
		// Set custom and default queries in store
		(0, _helper.updateCustomQuery)(props.componentId, props, currentValue);
		(0, _helper.updateDefaultQuery)(_this.internalComponent, props, currentValue);

		_this.updateQueryOptions(props, false);
		if (currentValue) {
			_this.setValue(currentValue, true, props);
		}
		_this.setReact(props, _this.internalComponent);
		_this.handleRange = (0, _helper.debounce)(_this.handleRange, 100);
		return _this;
	}

	ReactiveChart.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
		if (!(0, _helper.isEqual)(prevProps.options, this.props.options)) {
			// set options in state
			// eslint-disable-next-line
			this.setState({
				options: this.transformOptions(this.props.options, this.props)
			});
		}
		if (!(0, _utils.isQueryIdentical)(this.state.currentValue, this.props, prevProps, 'defaultQuery')) {
			this.updateDefaultQuery();
			// Clear the component value
			this.updateQuery('', this.props);
		}

		if (!(0, _utils.isQueryIdentical)(this.state.currentValue, this.props, prevProps, 'customQuery')) {
			this.updateQuery(this.state.currentValue, this.props);
		}

		if (this.props.value !== prevProps.value) {
			this.setValue(this.props.value);
		} else if (this.state.currentValue !== this.props.selectedValue && this.props.selectedValue !== prevProps.selectedValue) {
			var _props = this.props,
			    value = _props.value,
			    onChange = _props.onChange;

			if (value === undefined) {
				this.setValue(this.props.selectedValue);
			} else if (onChange) {
				onChange(this.props.selectedValue);
			} else {
				this.setValue(this.state.currentValue, true);
			}
		}
	};

	ReactiveChart.prototype.transformOptions = function transformOptions(options, props) {
		return (props.options && props.options[props.dataField] ? props.options[props.dataField].buckets : []).filter(function (item) {
			return !!String(item.key).length;
		});
	};

	ReactiveChart.prototype.render = function render() {
		var _props2 = this.props,
		    onDblClick = _props2.onDblClick,
		    onMouseDown = _props2.onMouseDown,
		    onMouseUp = _props2.onMouseUp,
		    onMouseMove = _props2.onMouseMove,
		    onMouseOut = _props2.onMouseOut,
		    onGlobalOut = _props2.onGlobalOut,
		    onContextMenu = _props2.onContextMenu,
		    isLoading = _props2.isLoading,
		    error = _props2.error,
		    loader = _props2.loader,
		    renderError = _props2.renderError;

		if (isLoading) {
			return loader || null;
		}
		if (error) {
			if (renderError) {
				if ((0, _helper.isFunction)(renderError)) {
					return renderError(error);
				}
				return renderError;
			}
			return null;
		}
		return _react2.default.createElement(_echartsForReact2.default, {
			option: this.getChartOptions(),
			onEvents: {
				click: this.handleClick,
				dblclick: onDblClick,
				mousedown: onMouseDown,
				mouseup: onMouseUp,
				mousemove: onMouseMove,
				mouseout: onMouseOut,
				globalout: onGlobalOut,
				contextmenu: onContextMenu,
				datazoom: this.handleRange
			}
		});
	};

	return ReactiveChart;
}(_react2.default.Component);

var _initialiseProps = function _initialiseProps() {
	var _this2 = this;

	this.setReact = function (props, componentId) {
		var react = props.react;

		if (react) {
			var newReact = (0, _helper.pushToAndClause)(react, _this2.internalComponent);
			props.watchComponent(componentId, newReact);
		} else {
			props.watchComponent(componentId, {
				and: _this2.internalComponent
			});
		}
	};

	this.updateDefaultQuery = function (queryOptions) {
		var props = _this2.props;
		var value = void 0;
		if (props.type === 'range') {
			value = (0, _utils.getNumericRangeArray)(props.range, props.queryFormat);
		}
		(0, _helper.updateInternalQuery)(_this2.internalComponent, queryOptions, value, _this2.props, ReactiveChart.generateQueryOptions(_this2.props, _this2.state.prevAfter, value), null);
	};

	this.histogramQuery = function (props) {
		var _query;

		var query = (_query = {}, _query[props.dataField] = {
			histogram: {
				field: props.dataField,
				offset: (0, _utils.getNumericRangeArray)(props.range, props.queryFormat)[0]
			}
		}, _query);
		if (props.nestedField) {
			return {
				inner: {
					aggs: query,
					nested: {
						path: props.nestedField
					}
				}
			};
		}
		return query;
	};

	this.updateQueryOptions = function (props) {
		var addAfterKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

		var queryOptions = ReactiveChart.generateQueryOptions(props, addAfterKey ? _this2.state.after : {}, _this2.state.currentValue);

		_this2.updateDefaultQuery(queryOptions);
	};

	this.handleClick = function () {
		var _props3 = _this2.props,
		    onClick = _props3.onClick,
		    useAsFilter = _props3.useAsFilter,
		    chartType = _props3.chartType;

		if (onClick) {
			onClick.apply(undefined, arguments);
		}
		if (useAsFilter && ![ChartTypes.Histogram, ChartTypes.Scatter].includes(chartType)) {
			var item = arguments.length <= 0 ? undefined : arguments[0];
			var value = void 0;
			if (item.data && item.data.name) {
				value = item.data.name;
			} else {
				value = item.data;
			}
			if (!Number.isNaN(parseInt(value, 10))) {
				value = parseInt(value, 10);
			}
			_this2.setValue(value);
		}
	};

	this.updateQuery = function (value, props) {
		var execute = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
		var customQuery = props.customQuery;

		var query = ReactiveChart.defaultQuery(value, props);
		var customQueryOptions = void 0;
		if (customQuery) {
			var _ref4 = customQuery(value, props) || {};

			query = _ref4.query;

			customQueryOptions = (0, _helper.getOptionsFromQuery)(customQuery(value, props));
			(0, _helper.updateCustomQuery)(props.componentId, props, value);
		}
		props.setQueryOptions(props.componentId, _extends({}, ReactiveChart.generateQueryOptions(props, _this2.state.prevAfter, _this2.state.currentValue), customQueryOptions), false);
		props.updateQuery({
			componentId: props.componentId,
			query: query,
			value: value,
			label: props.filterLabel,
			showFilter: props.showFilter,
			URLParams: props.URLParams,
			componentType: _constants.componentTypes.reactiveChart
		}, execute, false);
	};

	this.setValue = function (value) {
		var isDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
		var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _this2.props;

		var performUpdate = function performUpdate() {
			var handleUpdates = function handleUpdates() {
				_this2.updateQuery(value, props);
			};
			_this2.setState({
				currentValue: value
			}, handleUpdates);
		};
		if (isDefault) {
			_this2.updateQuery(value, props, false, false);
		} else {
			(0, _helper.checkValueChange)(props.componentId, value, props.beforeValueChange, performUpdate);
		}
	};

	this.getChartOptions = function () {
		var _props4 = _this2.props,
		    chartType = _props4.chartType,
		    title = _props4.title,
		    labelFormatter = _props4.labelFormatter,
		    xAxisName = _props4.xAxisName,
		    yAxisName = _props4.yAxisName,
		    rawData = _props4.rawData,
		    hits = _props4.hits,
		    xAxisField = _props4.xAxisField,
		    yAxisField = _props4.yAxisField;
		var _state = _this2.state,
		    options = _state.options,
		    currentValue = _state.currentValue;
		var setOption = _this2.props.setOption;

		var results = (0, _helper.parseHits)(hits) || [];
		if (setOption) {
			return setOption({
				aggregationData: options,
				rawData: rawData,
				value: currentValue,
				data: results,
				xAxisField: xAxisField,
				yAxisField: yAxisField
			});
		}
		return ReactiveChart.getOption({
			chartType: chartType,
			value: currentValue,
			aggregationData: options,
			title: title,
			labelFormatter: labelFormatter,
			xAxisName: xAxisName,
			yAxisName: yAxisName,
			xAxisField: xAxisField,
			yAxisField: yAxisField,
			data: results
		});
	};

	this.handleRange = function () {
		var _props5 = _this2.props,
		    useAsFilter = _props5.useAsFilter,
		    onDataZoom = _props5.onDataZoom;

		if (useAsFilter) {
			var echartInstance = arguments.length <= 1 ? undefined : arguments[1];
			var axis = echartInstance.getModel().option.xAxis[0];
			var option = echartInstance.getOption();
			var start = option.dataZoom[0].startValue;
			var end = option.dataZoom[0].endValue;
			var startRangeValue = axis.data[start];
			var endRangeValue = axis.data[end];
			var rangeValue = [startRangeValue.value !== undefined ? startRangeValue.value : startRangeValue, endRangeValue.value !== undefined ? endRangeValue.value : endRangeValue];
			_this2.setValue(rangeValue);
		}
		if (onDataZoom) {
			onDataZoom.apply(undefined, arguments);
		}
	};
};

ReactiveChart.generateQueryOptions = function (props, after) {
	var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	var queryOptions = (0, _helper.getQueryOptions)(props);
	var valueArray = Array.isArray(value) ? value : [value];
	return (0, _helper.getAggsQuery)(valueArray, queryOptions, props);
};

ReactiveChart.defaultQuery = function (value, props) {
	var query = null;
	var type = props.queryFormat === 'or' ? 'terms' : 'term';

	if (value) {
		var listQuery = void 0;
		if (props.queryFormat === 'or') {
			var _type, _ref;

			var should = [(_ref = {}, _ref[type] = (_type = {}, _type[props.dataField] = value, _type), _ref)];
			listQuery = {
				bool: {
					should: should
				}
			};
		} else {
			var currentValue = Array.isArray(value) ? value : [value];
			// adds a sub-query with must as an array of objects for each term/value
			var queryArray = currentValue.map(function (item) {
				var _type2, _ref2;

				return _ref2 = {}, _ref2[type] = (_type2 = {}, _type2[props.dataField] = item, _type2), _ref2;
			});
			listQuery = {
				bool: {
					must: queryArray
				}
			};
		}

		query = value ? listQuery : null;
	}

	if (query && props.nestedField) {
		return {
			nested: {
				path: props.nestedField,
				query: query
			}
		};
	}

	return query;
};

ReactiveChart.getOption = function (_ref3) {
	var chartType = _ref3.chartType,
	    aggregationData = _ref3.aggregationData,
	    data = _ref3.data,
	    value = _ref3.value,
	    title = _ref3.title,
	    labelFormatter = _ref3.labelFormatter,
	    xAxisName = _ref3.xAxisName,
	    yAxisName = _ref3.yAxisName,
	    xAxisField = _ref3.xAxisField,
	    yAxisField = _ref3.yAxisField;

	var chartTitle = void 0;
	if (title) {
		if (typeof title === 'string') {
			if (chartType === ChartTypes.Pie) {
				chartTitle = {
					text: title,
					left: 'center'
				};
			} else {
				chartTitle = {
					text: title
				};
			}
		} else {
			chartTitle = title;
		}
	}
	switch (chartType) {
		case ChartTypes.Scatter:
			return {
				title: chartTitle,
				tooltip: {
					trigger: 'item'
				},
				xAxis: {
					name: xAxisName
				},
				yAxis: {
					name: yAxisName
				},
				series: [{
					symbolSize: 20,
					data: data.map(function (d) {
						return [d[xAxisField], d[yAxisField]];
					}),
					type: 'scatter'
				}]
			};
		case ChartTypes.Line:
			return {
				title: chartTitle,
				tooltip: {
					trigger: 'item'
				},
				xAxis: {
					name: xAxisName,
					type: 'category',
					data: aggregationData.map(function (item) {
						return {
							value: item.key,
							name: item.key
						};
					})
				},
				yAxis: {
					type: 'value',
					name: yAxisName
				},
				series: [{
					data: aggregationData.map(function (item) {
						return {
							value: item.doc_count,
							name: item.key
						};
					}),
					type: 'line'
				}]
			};
		case ChartTypes.Bar:
			return {
				title: chartTitle,
				tooltip: {
					trigger: 'item'
				},
				xAxis: {
					type: 'category',
					name: xAxisName,
					data: aggregationData.map(function (item) {
						return {
							value: item.key,
							name: item.key
						};
					})
				},
				yAxis: {
					type: 'value',
					name: yAxisName
				},
				series: [{
					data: aggregationData.map(function (item) {
						return {
							value: item.doc_count,
							name: item.key
						};
					}),
					type: 'bar',
					showBackground: true,
					backgroundStyle: {
						color: 'rgba(180, 180, 180, 0.2)'
					}
				}]
			};
		case ChartTypes.Pie:
			return {
				title: chartTitle,
				tooltip: {
					trigger: 'item'
				},
				series: [{
					type: 'pie',
					radius: '50%',
					data: aggregationData.map(function (item) {
						return {
							value: item.doc_count,
							name: item.key
						};
					}),
					emphasis: {
						itemStyle: {
							shadowBlur: 10,
							shadowOffsetX: 0,
							shadowColor: 'rgba(0, 0, 0, 0.5)'
						}
					}
				}]
			};
		case ChartTypes.Histogram:
			{
				var xAxisData = aggregationData.map(function (item) {
					return {
						value: item.key,
						name: item.key
					};
				});
				var startIndex = -1;
				var endIndex = -1;
				if (value && Array.isArray(value)) {
					startIndex = xAxisData.findIndex(function (i) {
						return i.value === value[0];
					});
					endIndex = xAxisData.findIndex(function (i) {
						return i.value === value[1];
					});
				}
				return {
					title: chartTitle,
					toolbox: {
						feature: {
							dataZoom: {
								yAxisIndex: false,
								labelFormatter: labelFormatter
							},
							saveAsImage: {
								pixelRatio: 2
							}
						}
					},
					tooltip: {
						trigger: 'axis',
						axisPointer: {
							type: 'shadow'
						}
					},
					grid: {
						bottom: 90
					},
					dataZoom: [{
						type: 'inside',
						startValue: startIndex > -1 ? startIndex : undefined,
						endValue: endIndex > -1 ? endIndex : undefined
					}, {
						type: 'slider',
						startValue: startIndex > -1 ? startIndex : undefined,
						endValue: endIndex > -1 ? endIndex : undefined
					}],
					xAxis: {
						data: xAxisData,
						name: xAxisName,
						silent: false,
						splitLine: {
							show: false
						},
						splitArea: {
							show: false
						}
					},
					yAxis: {
						splitArea: {
							show: false
						},
						name: yAxisName
					},
					series: [{
						type: 'bar',
						data: aggregationData.map(function (item) {
							return {
								value: item.doc_count
							};
						}),
						// Set `large` for large data amount
						large: true
					}]
				};
			}

		default:
			return null;
	}
};

ReactiveChart.defaultRangeQuery = function (value, props) {
	var query = null;
	if (Array.isArray(value) && value.length) {
		query = (0, _utils.getRangeQueryWithNullValues)(value, props);
	}

	if (query && props.nestedField) {
		return {
			nested: {
				path: props.nestedField,
				query: query
			}
		};
	}

	return query;
};
ReactiveChart.propTypes = {
	// UI props
	filterLabel: _types2.default.string,
	// events
	onClick: _propTypes.func,
	onDblClick: _propTypes.func,
	onMouseDown: _propTypes.func,
	onMouseUp: _propTypes.func,
	onMouseMove: _propTypes.func,
	onMouseOut: _propTypes.func,
	onGlobalOut: _propTypes.func,
	onContextMenu: _propTypes.func,
	onDataZoom: _propTypes.func,
	// ---- user props ---
	// props to configure query
	componentId: _types2.default.stringRequired,
	URLParams: _types2.default.bool,
	dataField: _types2.default.stringRequired,
	showFilter: _types2.default.bool,
	customQuery: _types2.default.func,
	defaultQuery: _types2.default.func,
	react: _types2.default.react,
	size: _types2.default.number,
	index: _types2.default.string,
	queryFormat: _types2.default.queryFormatSearch,
	range: _types2.default.range,
	type: (0, _propTypes.oneOf)(['term', 'range', 'search', 'geo', 'suggestion']),
	// eslint-disable-next-line
	value: _propTypes.any,
	// props to configure chart
	chartType: (0, _propTypes.oneOf)(Object.values(ChartTypes)).isRequired,
	setOption: _propTypes.func,
	title: _types2.default.string,
	useAsFilter: _types2.default.bool,
	labelFormatter: _types2.default.func,
	xAxisName: _types2.default.string,
	yAxisName: _types2.default.string,
	xAxisField: _types2.default.string,
	yAxisField: _types2.default.string,
	// ---------//
	loader: _types2.default.title,
	onError: _types2.default.func,
	renderError: _types2.default.title,
	onChange: _types2.default.func,
	// redux props
	setQueryOptions: _types2.default.funcRequired,
	watchComponent: _types2.default.funcRequired,
	updateQuery: _types2.default.funcRequired,
	options: _types2.default.options,
	rawData: _types2.default.rawData,
	hits: _types2.default.hits,
	selectedValue: _types2.default.selectedValue,
	setCustomQuery: _types2.default.funcRequired,
	isLoading: _types2.default.bool,
	error: _types2.default.title
};

ReactiveChart.defaultProps = {
	useAsFilter: true
};

// Add componentType for SSR
ReactiveChart.componentType = _constants.componentTypes.multiList;

var mapStateToProps = function mapStateToProps(state, props) {
	return {
		options: props.nestedField && state.aggregations[(0, _transform.getInternalComponentID)(props.componentId)] ? state.aggregations[(0, _transform.getInternalComponentID)(props.componentId)].reactivesearch_nested : state.aggregations[(0, _transform.getInternalComponentID)(props.componentId)],
		hits: state.hits[(0, _transform.getInternalComponentID)(props.componentId)] && state.hits[(0, _transform.getInternalComponentID)(props.componentId)].hits,
		rawData: state.rawData[(0, _transform.getInternalComponentID)(props.componentId)],
		selectedValue: state.selectedValues[props.componentId] && state.selectedValues[props.componentId].value || null,
		isLoading: state.isLoading[(0, _transform.getInternalComponentID)(props.componentId)],
		error: state.error[(0, _transform.getInternalComponentID)(props.componentId)]
	};
};

var mapDispatchtoProps = function mapDispatchtoProps(dispatch) {
	return {
		watchComponent: function watchComponent(component, react) {
			return dispatch((0, _actions.watchComponent)(component, react));
		},
		setCustomQuery: function setCustomQuery(component, query) {
			return dispatch((0, _actions.setCustomQuery)(component, query));
		},
		setDefaultQuery: function setDefaultQuery(component, query) {
			return dispatch((0, _actions.setDefaultQuery)(component, query));
		},
		setQueryOptions: function setQueryOptions(component, props, execute) {
			return dispatch((0, _actions.setQueryOptions)(component, props, execute));
		},
		updateQuery: function updateQuery(updateQueryObject, execute, setInternalValue) {
			return dispatch((0, _actions.updateQuery)(updateQueryObject, execute, setInternalValue));
		}
	};
};

var ConnectedComponent = (0, _utils.connect)(mapStateToProps, mapDispatchtoProps)(function (props) {
	return _react2.default.createElement(ReactiveChart, _extends({ ref: props.myForwardedRef }, props));
});

// eslint-disable-next-line
var ForwardRefComponent = _react2.default.forwardRef(function (props, ref) {
	return _react2.default.createElement(
		_PreferencesConsumer2.default,
		{ userProps: props },
		function (preferenceProps) {
			var type = preferenceProps.type;
			if (!type) {
				if (preferenceProps.chartType === ChartTypes.Scatter) {
					type = 'search';
				}
			}
			return _react2.default.createElement(
				_ComponentWrapper2.default,
				_extends({}, preferenceProps, {
					type: type,
					internalComponent: true,
					componentType: _constants.componentTypes.reactiveChart,
					showHistogram: preferenceProps.type === 'range',
					setReact: false
				}),
				function () {
					return _react2.default.createElement(ConnectedComponent, _extends({}, preferenceProps, { type: type, myForwardedRef: ref }));
				}
			);
		}
	);
});
(0, _hoistNonReactStatics2.default)(ForwardRefComponent, ReactiveChart);

ForwardRefComponent.displayName = 'ReactiveChart';
exports.default = ForwardRefComponent;