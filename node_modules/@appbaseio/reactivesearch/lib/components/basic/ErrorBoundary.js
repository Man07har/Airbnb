'use strict';

exports.__esModule = true;

var _types = require('@appbaseio/reactivecore/lib/utils/types');

var _types2 = _interopRequireDefault(_types);

var _propTypes = require('prop-types');

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _utils = require('../../utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ErrorBoundary = function (_Component) {
	_inherits(ErrorBoundary, _Component);

	function ErrorBoundary() {
		var _temp, _this, _ret;

		_classCallCheck(this, ErrorBoundary);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.state = {
			error: null
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	ErrorBoundary.prototype.invokeErrorCallback = function invokeErrorCallback() {
		var error = this.props.error || this.state.error;
		if (this.props.onError) {
			this.props.onError(error, this.props.componentId);
		}
	};

	ErrorBoundary.getDerivedStateFromError = function getDerivedStateFromError(error) {
		return { error: error };
	};

	ErrorBoundary.prototype.componentDidCatch = function componentDidCatch() {
		this.invokeErrorCallback();
	};

	ErrorBoundary.prototype.componentDidUpdate = function componentDidUpdate() {
		this.invokeErrorCallback();
	};

	ErrorBoundary.prototype.render = function render() {
		var error = this.props.error || this.state.error;
		if (error) {
			if (this.props.renderError) {
				var componentId = this.props.componentId;

				return this.props.renderError(error, componentId);
			}
			// You can render any custom fallback UI
			return _react2.default.createElement(
				'div',
				null,
				_react2.default.createElement(
					'h2',
					null,
					'Error occured!'
				),
				_react2.default.createElement(
					'p',
					null,
					error.message
				)
			);
		}

		return this.props.children;
	};

	return ErrorBoundary;
}(_react.Component);

ErrorBoundary.propTypes = {
	children: _types2.default.children,
	// eslint-disable-next-line react/forbid-prop-types
	error: _propTypes.object,
	componentId: _types2.default.string,
	componentIds: (0, _propTypes.arrayOf)(_types2.default.string),
	renderError: _types2.default.func,
	onError: _types2.default.func
};
var mapStateToProps = function mapStateToProps(state, ownProps) {
	var listOfComponentsToSearch = Object.keys(state.error);
	if (ownProps.componentIds && ownProps.componentIds.length) {
		listOfComponentsToSearch = Object.keys(state.error).filter(function (componentId) {
			return ownProps.componentIds.includes(componentId);
		});
	}
	var error = listOfComponentsToSearch.map(function (componentId) {
		return state.error[componentId];
	})
	// Find the first non-null error
	.find(function (e) {
		return e;
	});
	var componentId = listOfComponentsToSearch.find(function (id) {
		return state.error[id];
	});
	return { error: error, componentId: componentId };
};

exports.default = (0, _utils.connect)(mapStateToProps, null)(ErrorBoundary);